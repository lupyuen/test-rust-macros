#s src/main.rs | 69 | 25 | 69 | 36
#s src/main.rs | 69 | 41 | 69 | 51
#s src/main.rs | 69 | 56 | 69 | 67
#s src/main.rs | 69 | 72 | 69 | 81
#s src/main.rs | 69 | 106 | 83 | 1
#s src/main.rs | 70 | 4 | 70 | 46
#s src/main.rs | 70 | 4 | 70 | 45
#s src/main.rs | 70 | 4 | 70 | 45
#s src/main.rs | 70 | 4 | 70 | 45
#s src/main.rs | 72 | 4 | 72 | 56
#s src/main.rs | 72 | 4 | 72 | 54
#s src/main.rs | 72 | 4 | 72 | 52
#s src/main.rs | 72 | 4 | 72 | 52
#m sensor::set_poll_rate_ms | src/main.rs | 72 | 4 | 72 | 52
#s src/main.rs | 72 | 29 | 72 | 51
start_sensor_listener: sensor_name has inferred type &Strn
#s src/main.rs | 72 | 29 | 72 | 40
#i start_sensor_listener | sensor_name | sensor::set_poll_rate_ms | devname | &Strn
start_sensor_listener: poll_time has inferred type u32
#s src/main.rs | 72 | 42 | 72 | 51
#i start_sensor_listener | poll_time | sensor::set_poll_rate_ms | poll_rate | u32
#s src/main.rs | 72 | 29 | 72 | 51
#s src/main.rs | 72 | 4 | 72 | 52
#s src/main.rs | 72 | 4 | 72 | 52
#s src/main.rs | 72 | 4 | 72 | 54
#s src/main.rs | 74 | 4 | 74 | 84
#s src/main.rs | 74 | 24 | 74 | 82
#s src/main.rs | 74 | 24 | 74 | 80
#s src/main.rs | 74 | 24 | 74 | 80
#m sensor::mgr_find_next_bydevname | src/main.rs | 74 | 24 | 74 | 80
#s src/main.rs | 74 | 56 | 74 | 79
start_sensor_listener: sensor_name has inferred type &Strn
#s src/main.rs | 74 | 56 | 74 | 67
#i start_sensor_listener | sensor_name | sensor::mgr_find_next_bydevname | devname | &Strn
start_sensor_listener: null_mut() has inferred type *mut sensor
#s src/main.rs | 74 | 69 | 74 | 79
#i start_sensor_listener | null_mut() | sensor::mgr_find_next_bydevname | prev_cursor | *mut sensor
#s src/main.rs | 74 | 56 | 74 | 79
#s src/main.rs | 74 | 24 | 74 | 80
#s src/main.rs | 74 | 24 | 74 | 80
#s src/main.rs | 74 | 24 | 74 | 82
#s src/main.rs | 76 | 4 | 81 | 5
#s src/main.rs | 76 | 4 | 81 | 5
#s src/main.rs | 76 | 7 | 76 | 34
#s src/main.rs | 76 | 7 | 76 | 20
#s src/main.rs | 76 | 7 | 76 | 20
#s src/main.rs | 76 | 24 | 76 | 34
#s src/main.rs | 76 | 24 | 76 | 34
#s src/main.rs | 76 | 24 | 76 | 34
#s src/main.rs | 76 | 7 | 76 | 34
#s src/main.rs | 76 | 35 | 81 | 5
#s src/main.rs | 78 | 8 | 78 | 99
#s src/main.rs | 78 | 23 | 78 | 97
#s src/main.rs | 78 | 23 | 78 | 95
#s src/main.rs | 78 | 23 | 78 | 95
#m sensor::new_sensor_listener | src/main.rs | 78 | 23 | 78 | 95
#s src/main.rs | 78 | 51 | 78 | 94
start_sensor_listener: sensor_key has inferred type &'static Strn
#s src/main.rs | 78 | 51 | 78 | 61
#i start_sensor_listener | sensor_key | sensor::new_sensor_listener | sensor_key | &'static Strn
start_sensor_listener: sensor_type has inferred type sensor_type_t
#s src/main.rs | 78 | 63 | 78 | 74
#i start_sensor_listener | sensor_type | sensor::new_sensor_listener | sensor_type | sensor_type_t
start_sensor_listener: handle_sensor_data has inferred type SensorValueFunc
#s src/main.rs | 78 | 76 | 78 | 94
#i start_sensor_listener | handle_sensor_data | sensor::new_sensor_listener | listener_func | SensorValueFunc
#s src/main.rs | 78 | 51 | 78 | 94
#s src/main.rs | 78 | 23 | 78 | 95
#s src/main.rs | 78 | 23 | 78 | 95
#s src/main.rs | 78 | 23 | 78 | 97
#s src/main.rs | 80 | 8 | 80 | 62
#s src/main.rs | 80 | 8 | 80 | 60
#s src/main.rs | 80 | 8 | 80 | 58
#s src/main.rs | 80 | 8 | 80 | 58
#m sensor::register_listener | src/main.rs | 80 | 8 | 80 | 58
#s src/main.rs | 80 | 34 | 80 | 57
start_sensor_listener: sensor_driver has inferred type *mut sensor
#s src/main.rs | 80 | 34 | 80 | 47
#i start_sensor_listener | sensor_driver | sensor::register_listener | sensor | *mut sensor
start_sensor_listener: listener has inferred type sensor_listener
#s src/main.rs | 80 | 49 | 80 | 57
#i start_sensor_listener | listener | sensor::register_listener | listener | sensor_listener
#s src/main.rs | 80 | 34 | 80 | 57
#s src/main.rs | 80 | 8 | 80 | 58
#s src/main.rs | 80 | 8 | 80 | 58
#s src/main.rs | 80 | 8 | 80 | 60
#s src/main.rs | 76 | 35 | 81 | 5
#s src/main.rs | 76 | 4 | 81 | 5
#s src/main.rs | 82 | 4 | 82 | 10
#s src/main.rs | 82 | 4 | 82 | 10
#s src/main.rs | 82 | 4 | 82 | 10
#s src/main.rs | 82 | 4 | 82 | 10
#s src/main.rs | 69 | 106 | 83 | 1
start_sensor_listener: updated infer.json
#s src/main.rs | 89 | 22 | 89 | 33
#s src/main.rs | 89 | 58 | 94 | 1
#s src/main.rs | 90 | 4 | 90 | 43
#s src/main.rs | 90 | 4 | 90 | 42
#s src/main.rs | 90 | 4 | 90 | 42
#s src/main.rs | 90 | 4 | 90 | 42
#s src/main.rs | 92 | 4 | 92 | 37
#s src/main.rs | 92 | 4 | 92 | 35
#s src/main.rs | 92 | 4 | 92 | 33
#s src/main.rs | 92 | 4 | 92 | 33
#m send_sensor_data | src/main.rs | 92 | 4 | 92 | 33
#s src/main.rs | 92 | 21 | 92 | 32
handle_sensor_data: sensor_data has inferred type &SensorValue
#s src/main.rs | 92 | 21 | 92 | 32
#i handle_sensor_data | sensor_data | send_sensor_data | sensor_data | &SensorValue
#s src/main.rs | 92 | 21 | 92 | 32
#s src/main.rs | 92 | 4 | 92 | 33
#s src/main.rs | 92 | 4 | 92 | 33
#s src/main.rs | 92 | 4 | 92 | 35
#s src/main.rs | 93 | 4 | 93 | 10
#s src/main.rs | 93 | 4 | 93 | 10
#s src/main.rs | 93 | 4 | 93 | 10
#s src/main.rs | 93 | 4 | 93 | 10
#s src/main.rs | 89 | 58 | 94 | 1
handle_sensor_data: updated infer.json
#s src/main.rs | 99 | 20 | 99 | 31
#s src/main.rs | 99 | 56 | 120 | 1
#s src/main.rs | 100 | 4 | 100 | 41
#s src/main.rs | 100 | 4 | 100 | 40
#s src/main.rs | 100 | 4 | 100 | 40
#s src/main.rs | 100 | 4 | 100 | 40
#s src/main.rs | 102 | 4 | 102 | 56
#s src/main.rs | 102 | 20 | 102 | 54
#s src/main.rs | 102 | 20 | 102 | 54
#s src/main.rs | 104 | 4 | 104 | 73
#s src/main.rs | 104 | 24 | 104 | 71
#s src/main.rs | 104 | 24 | 104 | 69
#s src/main.rs | 104 | 24 | 104 | 69
#s src/main.rs | 104 | 24 | 104 | 69
#s src/main.rs | 104 | 24 | 104 | 71
#s src/main.rs | 107 | 4 | 118 | 5
#s src/main.rs | 107 | 4 | 118 | 5
#s src/main.rs | 107 | 7 | 107 | 20
#s src/main.rs | 107 | 7 | 107 | 20
#s src/main.rs | 107 | 21 | 118 | 5
#s src/main.rs | 111 | 8 | 114 | 11
#s src/main.rs | 111 | 23 | 114 | 10
#s src/main.rs | 111 | 23 | 114 | 10
#m coap | src/main.rs | 111 | 23 | 114 | 10
send_sensor_data: sensor_data has inferred type &SensorValue
#i send_sensor_data | sensor_data | coap | singleton | &SensorValue
#s src/main.rs | 111 | 23 | 114 | 10
#s src/main.rs | 111 | 23 | 114 | 10
#s src/main.rs | 117 | 8 | 117 | 44
#s src/main.rs | 117 | 8 | 117 | 42
#s src/main.rs | 117 | 8 | 117 | 40
#s src/main.rs | 117 | 8 | 117 | 40
#s src/main.rs | 117 | 8 | 117 | 40
#s src/main.rs | 117 | 8 | 117 | 42
#s src/main.rs | 107 | 21 | 118 | 5
#s src/main.rs | 107 | 4 | 118 | 5
#s src/main.rs | 119 | 4 | 119 | 10
#s src/main.rs | 119 | 4 | 119 | 10
#s src/main.rs | 119 | 4 | 119 | 10
#s src/main.rs | 119 | 4 | 119 | 10
#s src/main.rs | 99 | 56 | 120 | 1
send_sensor_data: updated infer.json
#![feature(prelude_import)]
#![no_std]
#![feature(trace_macros)]
//  Enable tracing of macros
#![feature(proc_macro_hygiene)]
//  Allow proc macros to be unhygienic
#![feature(custom_attribute)]
#[prelude_import]
use ::std::prelude::v1::*;
#[macro_use]
extern crate std as std;
//  Allow custom attributes like [safe_wrap]

/// Testing infer_type
#[cfg(feature = "test_infer_type")]
#[allow(dead_code)]
mod test_infer_type {
    extern crate macros as mynewt_macros;
    extern crate mynewt;
    use core::ptr::{
                    //null,
                    null_mut};
    use mynewt::{result::*, sys::console,
                 hw::sensor::{self, sensor_type_t,
                              //sensor_data_func,
                              //sensor_data_func_untyped,
                              //sensor_listener,
                              //sensor_data_ptr,
                              //sensor_ptr,
                              //sensor_arg,
                              SensorValue, SensorValueType,
                              SENSOR_TYPE_AMBIENT_TEMPERATURE_RAW},
                 encoding::{coap_context::*}, libs::{sensor_network}, Strn,
                 coap, d};
    use mynewt_macros::{infer_type, init_strn, strn};

    //  From stm32bluepill-mynewt-sensor/rust/visual/src/lib.rs
    const _: &str =
        "-------------------------------------------------------------";

    // This Rust program polls the internal temperature sensor every
    // 10 seconds and sends the sensor data to the server over NB-IoT.
    /// Will be run upon startup to initialise the app
    fn on_start() -> MynewtResult<()> {
        console::print("on_start\n");
        // Blue Pill's internal temperature sensor
        let SENSOR_DEVICE =
            &Strn{rep: mynewt::StrnRep::ByteStr(b"temp_stm32_0\x00"),};
        // Poll the sensor every 10,000 milliseconds (10 seconds)
        let SENSOR_POLL_TIME = 10000;
        // Sensor data will be transmitted to server as field `t`
        let TEMP_SENSOR_KEY = &Strn{rep: mynewt::StrnRep::ByteStr(b"t\x00"),};
        // Sensor data is raw temperature in whole numbers (0 to 4095)
        let TEMP_SENSOR_TYPE = SENSOR_TYPE_AMBIENT_TEMPERATURE_RAW;
        // Poll the sensor every 10 seconds
        start_sensor_listener(SENSOR_DEVICE, TEMP_SENSOR_KEY,
                              TEMP_SENSOR_TYPE, SENSOR_POLL_TIME)?;
        // Start connecting to NB-IoT network in a background task
        sensor_network::start_server_transport()?;

        // Return success to `main()` function
        Ok(())
    }

    //  Infer the missing types
    #[doc = " Poll the temperature sensor every 10 seconds"]
    #[doc = " and call function `handle_sensor_data()`."]
    fn start_sensor_listener(sensor_name: &Strn, sensor_key: &'static Strn,
                             sensor_type: sensor_type_t, poll_time: u32)
     -> MynewtResult<()> {
        console::print("start_sensor_listener\n");
        // Schedule the sensor to be polled every 10 seconds
        sensor::set_poll_rate_ms(sensor_name, poll_time)?;
        // Find the sensor driver by name
        let sensor_driver =
            sensor::mgr_find_next_bydevname(sensor_name, null_mut())?;
        // If the sensor driver has been found...
        if sensor_driver != null_mut() {
            // Create a sensor listener that will call function `handle_sensor_data` after polling the sensor data
            let listener =
                sensor::new_sensor_listener(sensor_key, sensor_type,
                                            handle_sensor_data)?;
            // Register the sensor listener
            sensor::register_listener(sensor_driver, listener)?;
        }
        Ok(())
    }

    //  Infer the missing types
    #[doc = " This listener function is called every 10 seconds to"]
    #[doc = " handle the polled sensor data. We convert the sensor data"]
    #[doc = " to our transmission format and transmit to the server."]
    fn handle_sensor_data(sensor_data: &SensorValue) -> MynewtResult<()> {
        console::print("handle_sensor_data\n");
        // Transmit the sensor data to the server
        send_sensor_data(sensor_data)?;
        Ok(())
    }

    //  Infer the missing types
    #[doc = " Compose a CoAP JSON message with the Sensor Key (field name)"]
    #[doc = " and Sensor Value in `sensor_data` and send to the CoAP server."]
    fn send_sensor_data(sensor_data: &SensorValue) -> MynewtResult<()> {
        console::print("send_sensor_data\n");
        // Get a randomly-generated device ID that changes each time we restart the device
        let device_id = &sensor_network::get_device_id()?;
        // Start composing a CoAP message
        let network_ready = sensor_network::init_server_post(DEFAULT_URI)?;
        // Proceed to compose the CoAP message only when
        // the device has connected to the NB-IoT network
        if network_ready {
            // Create a CoAP message with payload in JSON format
            // Fill in the random device ID
            // And the sensor data like `t: 2870`
            let _payload =
                // Transmit the CoAP message to the CoAP Server over
                // NB-IoT. This takes place in a background task.


                //  TODO

                //  use cty::*;               //  Import C types from cty library: https://crates.io/crates/cty

                //  Import Mynewt macros from `macros` library

                //  Import Mynewt result and error types
                //self,             //  Import Mynewt OS functions
                //  Import Mynewt OS types
                //  Import Mynewt JSON Encoder Context
                //self,
                //COAP_CONTEXT,
                //ToBytesOptionalNull,

                //tinycbor,         //  Import Mynewt TinyCBOR API
                //mynewt_rust,      //  Import Mynewt Rust Helper API
                //sensor_network,   //  Import Mynewt Sensor Network API
                //  Import Mynewt Sensor CoAP API
                //self,
                //sensor_value,

                //coap, d, fill_zero,   //  Import Mynewt macros

                ///////////////////////////////////////////////////////////////////////////////
                //  Testing

                ////
                ////
                ////
                ////
                ////
                ////
                ////
                ////
                /*
                    type Out<T> = &'static mut T;
                    type Ptr = *mut ::cty::c_void;
                    const NULL: Ptr = 0 as Ptr;

                    task_init(                      //  Create a new task and start it...
                        out!( NETWORK_TASK ),       //  Task object will be saved here
                        strn!( "network" ),         //  Name of task
                        Some( network_task_func ),  //  Function to execute when task starts
                        NULL,  //  Argument to be passed to above function
                        10,    //  Task priority: highest is 0, lowest is 255 (main task is 127)
                        os::OS_WAIT_FOREVER as u32,   //  Don't do sanity / watchdog checking
                        out!( NETWORK_TASK_STACK ),   //  Stack space for the task
                        NETWORK_TASK_STACK_SIZE       //  Size of the stack (in 4-byte units)
                    )?;                               //  `?` means check for error

                    pub fn OLDtask_init(
                        t: Out<os_task>,  //  TODO: *mut os_task
                        name: &Strn,      //  TODO: *const ::cty::c_char
                        func: os_task_func_t,
                        arg: Ptr,         //  TODO: *mut ::cty::c_void
                        prio: u8,
                        sanity_itvl: os_time_t,
                        stack_bottom: Out<[os_stack_t]>,  //  TODO: *mut os_stack_t
                        stack_size: usize,                //  TODO: u16
                    ) -> MynewtResult<()> {               //  TODO: ::cty::c_int;
                        extern "C" {
                            pub fn os_task_init(
                                t: *mut os_task,
                                name: *const ::cty::c_char,
                                func: os_task_func_t,
                                arg: *mut ::cty::c_void,
                                prio: u8,
                                sanity_itvl: os_time_t,
                                stack_bottom: *mut os_stack_t,
                                stack_size: u16,
                            ) -> ::cty::c_int;
                        }
                        Strn::validate_bytestr(name.bytestr);  //  TODO
                        unsafe {
                            let res = os_task_init(
                                t,
                                name.bytestr.as_ptr() as *const ::cty::c_char,  //  TODO
                                func,
                                arg,
                                prio,
                                sanity_itvl,
                                stack_bottom.as_ptr() as *mut os_stack_t,  //  TODO
                                stack_size as u16       //  TODO
                            );
                            if res == 0 { Ok(()) }
                            else { Err(MynewtError::from(res)) }
                        }
                    }

                    #[doc = " Initialize a task."]
                    #[doc = ""]
                    #[doc = " This function initializes the task structure pointed to by t,"]
                    #[doc = " clearing and setting it's stack pointer, provides sane defaults"]
                    #[doc = " and sets the task as ready to run, and inserts it into the operating"]
                    #[doc = " system scheduler."]
                    #[doc = ""]
                    #[doc = " - __`t`__: The task to initialize"]
                    #[doc = " - __`name`__: The name of the task to initialize"]
                    #[doc = " - __`func`__: The task function to call"]
                    #[doc = " - __`arg`__: The argument to pass to this task function"]
                    #[doc = " - __`prio`__: The priority at which to run this task"]
                    #[doc = " - __`sanity_itvl`__: The time at which this task should check in with the"]
                    #[doc = "                    sanity task.  OS_WAIT_FOREVER means never check in"]
                    #[doc = "                    here."]
                    #[doc = " - __`stack_bottom`__: A pointer to the bottom of a task's stack"]
                    #[doc = " - __`stack_size`__: The overall size of the task's stack."]
                    #[doc = ""]
                    #[doc = " Return: 0 on success, non-zero on failure."]
                    fn dummy() {}
                */


                // Note this useful idiom: importing names from outer (for mod tests) scope.
                // use super::*;


                //assert_eq!(1, 1);

                // If `e` is an expression like `123`, `i * 2`, `func(i)`...
                // Add 88 to the expression and return it.
                // If `e` is an expression, `i` is an identifier like `myvar`, `blk` is a block of statements...
                // Add 88 and the value of `i` to the expression.
                // Execute the code block.
                // Return the result.

                //  This rule matches zero or more tokens.
                //  For all matched tokens, convert into a string.

                // Helper macro to parse a JSON `key: value` entry. The entry should be followed by a trailing comma.
                // For example: When parsing the JSON code `{ "device": "010203" , (omitted) }`, the macro will be called like this:
                // ```
                // parse!( @json @object context ["device"] ("010203") , (omitted) )
                // ```

                //  Append to the "values" array e.g.
                //    {"key":"device", "value":"010203"},
                //  $crate::coap_item_str!(@$enc $obj, $($key)+, $value);

                //  Continue expanding the rest of the JSON.
                //  $crate::parse!(@$enc @object $obj () ($($rest)*) ($($rest)*));

                // The caller shall pass in a recipe for the soup, 
                // say `salt + 88`
                // We use our own salt, say Table Salt.
                // We try to use our salt, but the recipe 
                // actually requires a different salt, 
                // like Sea Salt.
                // Rust Compiler fails with a Hygiene Error.

                // The caller shall pass in 2 things: 
                // Which salt to use
                // and the recipe (like `salt + 88`)
                // We use whatever salt the caller passes in. 
                // Hence we use `$salt` instead of `salt`.
                // Then we use the same salt inside the recipe.
                // It works!

                // We try to make soup with our salt and recipe...
                // If you're testing other macros, comment out the `+ salt` part or the code will never compile
                // But the salt isn't the same inside the recipe.  
                // Rust Compiler fails with Hygiene Error:
                // `salt` not found in this scope.
                 //  Return the cooked soup.

                // First we tell the macro which salt we're using...
                // Then we tell the macro what to do with that salt.
                //  It works!
                //  Return the cooked soup.

                //  Import everything from outer scope.


                //  Expression
                //  Identifier
                //  Code Block
                // Shows `The value of x and y are 2 and 3`. Result is 99.




                //  Start tracing macros
                //  Stop tracing macros


                {
                    "begin json root";
                    {
                        "begin json coap_root";
                        unsafe {
                            mynewt::libs::sensor_network::prepare_post(mynewt::encoding::APPLICATION_JSON)?;
                        }
                        unsafe {
                            mynewt::libs::sensor_coap::json_rep_start_root_object();
                        }
                        {
                            {
                                "begin json coap_array , object : COAP_CONTEXT , key : values";
                                {
                                    "<< jarri , o: COAP_CONTEXT, k: values";
                                    let key_with_null: &str = "values\u{0}";
                                    unsafe {
                                        mynewt::libs::mynewt_rust::json_helper_set_array(COAP_CONTEXT.to_void_ptr(),
                                                                                         COAP_CONTEXT.key_to_cstr(key_with_null.as_bytes()));
                                    };
                                };
                                {
                                    " >>  >> \"device\" >> : device_id , sensor_data";
                                    "add1 key : \"device\" value : $crate::parse!(@ json device_id) to object :\nCOAP_CONTEXT";
                                    {
                                        "begin json coap_item_str , parent : COAP_CONTEXT , key : \"device\" , val :\n$crate::parse!(@ json device_id)";
                                        {
                                            "begin json coap_item , array : COAP_CONTEXT";
                                            {
                                                "<< jitmi c: COAP_CONTEXT";
                                                let key_with_null: &str =
                                                    "COAP_CONTEXT\u{0}";
                                                unsafe {
                                                    mynewt::libs::mynewt_rust::json_helper_object_array_start_item(COAP_CONTEXT.key_to_cstr(key_with_null.as_bytes()))
                                                };
                                            };
                                            {
                                                {
                                                    "-- jtxti o: COAP_CONTEXT, k: key, v: \"device\"";
                                                    let key_strn: &Strn =
                                                        &Strn::new(b"key\x00");
                                                    let value_strn: &Strn =
                                                        &Strn::new(b"device\x00");
                                                    unsafe {
                                                        COAP_CONTEXT.json_set_text_string(key_strn,
                                                                                          value_strn)
                                                    };
                                                };
                                                {
                                                    "-- jtxti o: COAP_CONTEXT, k: value, v: $crate::parse!(@ json device_id)";
                                                    let key_strn: &Strn =
                                                        &Strn::new(b"value\x00");
                                                    let value_strn: &Strn =
                                                        device_id;
                                                    unsafe {
                                                        COAP_CONTEXT.json_set_text_string(key_strn,
                                                                                          value_strn)
                                                    };
                                                };
                                            };
                                            {
                                                ">>";
                                                let key_with_null: &str =
                                                    "COAP_CONTEXT\u{0}";
                                                unsafe {
                                                    mynewt::libs::mynewt_rust::json_helper_object_array_end_item(COAP_CONTEXT.key_to_cstr(key_with_null.as_bytes()))
                                                };
                                            };
                                            "end json coap_item";
                                        };
                                        "end json coap_item_str";
                                    };
                                    "--------------------";
                                    " >>  >> sensor_data >> ";
                                    "--------------------";
                                    {
                                        "begin json coap_item_int_val , c : COAP_CONTEXT , val : sensor_data";
                                        if let SensorValueType::Uint(val) =
                                               sensor_data.val {
                                            {
                                                "begin json coap_item_int , key : sensor_data.key , value : val";
                                                {
                                                    "begin json coap_item , array : COAP_CONTEXT";
                                                    {
                                                        "<< jitmi c: COAP_CONTEXT";
                                                        let key_with_null:
                                                                &str =
                                                            "COAP_CONTEXT\u{0}";
                                                        unsafe {
                                                            mynewt::libs::mynewt_rust::json_helper_object_array_start_item(COAP_CONTEXT.key_to_cstr(key_with_null.as_bytes()))
                                                        };
                                                    };
                                                    {
                                                        {
                                                            "-- jtxte o: COAP_CONTEXT, k: \"key\", v: sensor_data.key";
                                                            let key_with_opt_null:
                                                                    &[u8] =
                                                                "key".to_bytes_optional_nul();
                                                            let value_with_opt_null:
                                                                    &[u8] =
                                                                sensor_data.key.to_bytes_optional_nul();
                                                            unsafe {
                                                                mynewt::libs::mynewt_rust::json_helper_set_text_string(COAP_CONTEXT.to_void_ptr(),
                                                                                                                       COAP_CONTEXT.key_to_cstr(key_with_opt_null),
                                                                                                                       COAP_CONTEXT.value_to_cstr(value_with_opt_null))
                                                            };
                                                        };
                                                        {
                                                            "-- jinte o: COAP_CONTEXT, k: \"value\", v: val";
                                                            let key_with_opt_null:
                                                                    &[u8] =
                                                                "value".to_bytes_optional_nul();
                                                            let value =
                                                                val as u64;
                                                            unsafe {
                                                                mynewt::libs::mynewt_rust::json_helper_set_int(COAP_CONTEXT.to_void_ptr(),
                                                                                                               COAP_CONTEXT.key_to_cstr(key_with_opt_null),
                                                                                                               value)
                                                            };
                                                        };
                                                    };
                                                    {
                                                        ">>";
                                                        let key_with_null:
                                                                &str =
                                                            "COAP_CONTEXT\u{0}";
                                                        unsafe {
                                                            mynewt::libs::mynewt_rust::json_helper_object_array_end_item(COAP_CONTEXT.key_to_cstr(key_with_null.as_bytes()))
                                                        };
                                                    };
                                                    "end json coap_item";
                                                };
                                                "end json coap_item_int";
                                            };
                                        } else {
                                            unsafe {
                                                COAP_CONTEXT.fail(CoapError::VALUE_NOT_UINT)
                                            };
                                        }
                                        "end json coap_item_int_val";
                                    };
                                    "--------------------";
                                };
                                {
                                    ">>";
                                    let key_with_null: &str = "values\u{0}";
                                    unsafe {
                                        mynewt::libs::mynewt_rust::json_helper_close_array(COAP_CONTEXT.to_void_ptr(),
                                                                                           COAP_CONTEXT.key_to_cstr(key_with_null.as_bytes()))
                                    };
                                };
                                "end json coap_array";
                            };
                        };
                        unsafe {
                            mynewt::libs::sensor_coap::json_rep_end_root_object();
                        }
                        "end json coap_root";
                    };
                    "end json root";
                    ()
                };
            sensor_network::do_server_post()?;
        }
        Ok(())
    }
    const _: &str =
        "-------------------------------------------------------------";
    const DEFAULT_URI: &Strn = &Strn{rep: mynewt::StrnRep::ByteStr(b"\x00"),};
}
/// Testing safe_wrap
#[cfg(feature = "test_safe_wrap")]
mod test_safe_wrap {
    extern crate macros as proc_macros;
    use proc_macros::{init_strn};
    extern crate mynewt;
    use mynewt::{result::*,
                 kernel::os::{os_eventq, os_task, os_stack_t, os_task_func_t,
                              os_time_t}, hw::sensor::{sensor},
                 encoding::{coap_context::{}}, libs::{sensor_coap::{}}, NULL,
                 Out, Ptr, Strn};
    fn test_safe_wrap() -> MynewtResult<()> {
        pub fn get_device_id() -> MynewtResult<Strn> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn get_device_id() -> *const ::cty::c_char;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = get_device_id();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(Strn::from_cstr(result_value as *const u8))
            }
        }
        extern "C" {
            pub static mut os_main_task: os_task;
        }
        #[doc = ""]
        pub fn start_server_transport() -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = ""]
                pub fn start_server_transport() -> ::cty::c_int;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = start_server_transport();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                if result_value == 0 {
                    Ok(())
                } else { Err(MynewtError::from(result_value)) }
            }
        }
        pub fn init_server_post(uri: &Strn) -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn init_server_post(uri: *const ::cty::c_char) -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            uri.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    init_server_post(uri.as_ptr() as *const ::cty::c_char);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn do_server_post() -> MynewtResult<bool> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn do_server_post() -> bool;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = do_server_post();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Set the sensor poll rate"]
        #[doc = ""]
        #[doc = " - __`devname`__: Name of the sensor"]
        #[doc = " - __`poll_rate`__: The poll rate in milli seconds"]
        pub fn set_poll_rate_ms(devname: &Strn, poll_rate: u32)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc = " Set the sensor poll rate"]
                #[doc = ""]
                #[doc = " - __`devname`__: Name of the sensor"]
                #[doc = " - __`poll_rate`__: The poll rate in milli seconds"]
                pub fn sensor_set_poll_rate_ms(devname: *const ::cty::c_char,
                                               poll_rate: u32)
                 -> ::cty::c_int;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            devname.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    sensor_set_poll_rate_ms(devname.as_ptr() as
                                                *const ::cty::c_char,
                                            poll_rate as u32);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                if result_value == 0 {
                    Ok(())
                } else { Err(MynewtError::from(result_value)) }
            }
        }
        #[doc =
              " Search the sensor list and find the next sensor that corresponds"]
        #[doc = " to a given device name."]
        #[doc = ""]
        #[doc = " - __`devname`__: The device name to search for"]
        #[doc =
              " - __`sensor`__: The previous sensor found with this device name"]
        #[doc = ""]
        #[doc = " Return: 0 on success, non-zero error code on failure"]
        pub fn mgr_find_next_bydevname(devname: &Strn,
                                       prev_cursor: *mut sensor)
         -> MynewtResult<*mut sensor> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                      " Search the sensor list and find the next sensor that corresponds"]
                #[doc = " to a given device name."]
                #[doc = ""]
                #[doc = " - __`devname`__: The device name to search for"]
                #[doc =
                      " - __`sensor`__: The previous sensor found with this device name"]
                #[doc = ""]
                #[doc =
                      " Return: 0 on success, non-zero error code on failure"]
                pub fn sensor_mgr_find_next_bydevname(devname:
                                                          *const ::cty::c_char,
                                                      prev_cursor:
                                                          *mut sensor)
                 -> *mut sensor;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            devname.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    sensor_mgr_find_next_bydevname(devname.as_ptr() as
                                                       *const ::cty::c_char,
                                                   prev_cursor as
                                                       *mut sensor);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        #[doc = " Pull a single item off the event queue and call it's event"]
        #[doc = " callback."]
        #[doc = ""]
        #[doc = " - __`evq`__: The event queue to pull the item off."]
        pub fn eventq_run(evq: *mut os_eventq) -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                      " Pull a single item off the event queue and call it's event"]
                #[doc = " callback."]
                #[doc = ""]
                #[doc = " - __`evq`__: The event queue to pull the item off."]
                pub fn os_eventq_run(evq: *mut os_eventq);
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                os_eventq_run(evq as *mut os_eventq);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(())
            }
        }
        #[doc =
              " Retrieves the default event queue processed by OS main task."]
        #[doc = ""]
        #[doc = " Return:                      The default event queue."]
        pub fn eventq_dflt_get() -> MynewtResult<*mut os_eventq> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                #[doc =
                      " Retrieves the default event queue processed by OS main task."]
                #[doc = ""]
                #[doc =
                      " Return:                      The default event queue."]
                pub fn os_eventq_dflt_get() -> *mut os_eventq;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value = os_eventq_dflt_get();
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                Ok(result_value)
            }
        }
        pub fn task_init(arg1: Out<os_task>, arg2: &Strn,
                         arg3: os_task_func_t, arg4: Ptr, arg5: u8,
                         arg6: os_time_t, arg7: Out<[os_stack_t]>, arg8: u16)
         -> MynewtResult<()> {
            "----------Insert Extern Decl: `extern C { pub fn ... }`----------";
            extern "C" {
                pub fn os_task_init(arg1: *mut os_task,
                                    arg2: *const ::cty::c_char,
                                    arg3: os_task_func_t,
                                    arg4: *mut ::cty::c_void, arg5: u8,
                                    arg6: os_time_t, arg7: *mut os_stack_t,
                                    arg8: u16) -> ::cty::c_int;
            }
            "----------Insert Validation: `Strn::validate_bytestr(name.bytestr)`----------";
            arg2.validate();
            unsafe {
                "----------Insert Call: `let result_value = os_task_init(`----------";
                let result_value =
                    os_task_init(arg1 as *mut os_task,
                                 arg2.as_ptr() as *const ::cty::c_char,
                                 arg3 as os_task_func_t,
                                 arg4 as *mut ::cty::c_void, arg5 as u8,
                                 arg6 as os_time_t,
                                 arg7.as_ptr() as *mut os_stack_t,
                                 arg8 as u16);
                "----------Insert Result: `Ok(Strn::from_cstr(result_value))`----------";
                if result_value == 0 {
                    Ok(())
                } else { Err(MynewtError::from(result_value)) }
            }
        }
        let _test_local = Strn{rep: mynewt::StrnRep::ByteStr(b"hello\x00"),};
        Ok(())
    }
    static _test_static: Strn =
        Strn{rep: mynewt::StrnRep::ByteStr(b"hello\x00"),};
}
fn main() { }
